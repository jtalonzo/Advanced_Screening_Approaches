# -*- coding: utf-8 -*-
"""relation_extractor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DYuYjz5Ds-UJ_Mj8gLpdlCoyI29thObB
"""

from spacy.language import Language
from spacy.util import registry  # Corrected import for registry
from spacy.pipeline.trainable_pipe import TrainablePipe
from spacy.tokens import Doc
from thinc.api import Model, Linear, chain, Logistic
from thinc.types import Floats2d, Ints1d, Ragged, cast
from typing import List, Tuple, Callable, Optional, Dict, Any, Iterable
import numpy as np  # Required for array operations
from thinc.api import Ragged  # Needed for handling Ragged tensors

from spacy.tokens import Doc
from collections import defaultdict

# Register the extension if not already registered
if not Doc.has_extension("rel"):
    Doc.set_extension("rel", default=defaultdict(dict))

@registry.architectures("rel_classification_layer.v1")
def create_classification_layer(nO: int = 9, nI: int = 128) -> Model[Floats2d, Floats2d]:
    """Create a classification layer with default nO and nI."""
    model = chain(Linear(nO=nO, nI=nI), Logistic())
    return model

print("Architecture 'rel_classification_layer.v1' registered successfully!")

@registry.architectures("rel_model.v1")
def create_relation_model(tok2vec: Model, create_instance_tensor: Model,
                          classification_layer: Model, instance_generator):
    def forward_model(docs: List[Doc], is_train: bool):
        instances = [list(instance_generator(doc)) for doc in docs]
        tensors, backprop_tensors = create_instance_tensor(instances, is_train=is_train)
        outputs, backprop_outputs = classification_layer(tensors, is_train=is_train)
        return outputs, backprop_outputs

    return Model("relation_extractor", forward_model, layers=[tok2vec, create_instance_tensor, classification_layer])

print("Architecture 'rel_model.v1' registered successfully!")

# Register the missing rel_instance_tensor architecture
@registry.architectures("rel_instance_tensor.v1")
def create_instance_tensor(nO: int, nI: int, pooling: Model, tok2vec: Model) -> Model:
    """
    Custom architecture to create instance tensors for relation extraction.
    """
    # Ensure `tok2vec` and `pooling` are valid thinc Model objects
    if not isinstance(tok2vec, Model):
        raise ValueError("tok2vec must be a valid Thinc Model.")
    if not isinstance(pooling, Model):
        raise ValueError("pooling must be a valid Thinc Model.")

    # Build the final model
    model = chain(
        tok2vec,             # Feature extractor
        pooling,             # Pooling layer
        Linear(nO=nO, nI=nI) # Final classification layer
    )
    return model

print("Architecture 'rel_instance_tensor.v1' registered successfully!")

@registry.architectures("rel_instance_generator.v1")
def create_rel_instance_generator() -> Model:
    """Create the relation instance generator model."""
    def forward_model(X, is_train):
        return X, lambda dX: dX  # Example: Simple passthrough model
    return Model("rel_instance_generator", forward_model)

print("rel_instance_generator.v1' registered successfully!")

# Define and register the custom relation extractor factory


@Language.factory("relation_extractor")
def make_relation_extractor(nlp, name, model):
    # Ensure the model is resolved from the registry if passed as a dict
    if isinstance(model, dict):
        model = registry.resolve(model)
    if model is None:
        raise ValueError("Model cannot be None. Ensure a valid model is passed.")

    print("RelationExtractor factory is resolving the model successfully!")
    return RelationExtractor(nlp, name, model)

class RelationExtractor(TrainablePipe):
    def __init__(self, nlp, name, model):
        super().__init__(nlp, name)
        self.model = model

    @property
    def labels(self):
        """Return the list of relation labels."""
        return self._labels

    def add_label(self, label: str):
        """Add a new relation label."""
        if label not in self._labels:
            self._labels.append(label)

def initialize(self, get_examples, nlp=None, labels=None):
    if not self.model:
        raise ValueError("The model is not initialized. Check the pipeline creation process.")
    print("Initializing model...")
    examples = list(get_examples())
    truths = self._examples_to_truth(examples)
    self.model.initialize(X=examples, Y=truths)
    print("Model initialized successfully.")

    def _examples_to_truth(self, examples):
        """Convert training examples into truth data."""
        truths = []
        for example in examples:
            truth = defaultdict(dict)
            for key, value in example.reference._.rel.items():
                truth[key] = value
            truths.append(truth)
        return truths

def update(self, examples, losses=None, sgd=None, drop=0.0):
    """Update the model with examples and compute loss.

    Args:
        examples (list): List of Example objects for training.
        losses (dict): Dictionary to store loss values.
        sgd: Optimizer function.
        drop (float): Dropout rate applied during training.
    """
    # Convert examples to truth data
    truths = self._examples_to_truth(examples)

    # Predict scores using the model
    predictions = self.model.predict([example.reference for example in examples])

    # Compute loss
    loss = self.model.get_loss(truths, predictions)

    # Apply gradients via SGD
    if sgd is not None:
        self.model.backpropagate(loss, sgd=sgd, drop=drop)

    # Update the losses dictionary
    if losses is not None:
        losses[self.name] = loss

    def predict(self, docs):
        """Make predictions on the given docs."""
        return self.model.predict(docs)

    def set_annotations(self, docs, scores):
        """Set annotations on the docs based on scores."""
        for doc, score in zip(docs, scores):
            doc._.rel = score

# Register the 'rel' attribute extension if not already registered
if not Doc.has_extension("rel"):
    Doc.set_extension("rel", default=lambda: defaultdict(dict))

print("Custom Relation Extractor factory registered successfully!")